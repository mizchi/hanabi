// Generated by CoffeeScript 1.7.1
(function() {
  setTimeout(function() {
    var clear_point, cvs, frame, hanabi, hibana, rad, render;
    hanabi = {
      'quantity': 256,
      'size': 4.8,
      'circle': 0.965,
      'gravity': 1.2,
      'speed': 7.8,
      'top': 3.6,
      'left': 2.1,
      'color': '#ffcc00'
    };
    rad = Math.PI * 2;
    hibana = [];
    cvs = {
      'elem': void 0,
      'width': 0,
      'height': 0,
      'ctx': void 0,
      'left': 0,
      'top': 0,
      'pos_x': 0,
      'pos_y': 0
    };
    setTimeout(function() {
      var angle, i, speed, _i, _ref;
      cvs.pos_y = (cvs.height / hanabi.top) - cvs.top;
      cvs.pos_x = cvs.width / hanabi.left - cvs.left;
      for (i = _i = 0, _ref = hanabi.quantity; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        angle = Math.random() * rad;
        speed = Math.random() * hanabi.speed;
        hibana.push({
          'pos_x': cvs.pos_x,
          'pos_y': cvs.pos_y,
          'vel_x': Math.cos(angle) * speed,
          'vel_y': Math.sin(angle) * speed
        });
      }
      return requestAnimationFrame(render);
    });
    clear_point = function(x, y, size) {
      return setTimeout(function() {
        return requestAnimationFrame(function() {
          cvs.ctx.save();
          cvs.ctx.beginPath();
          cvs.ctx.arc(x, y, size * 1.2, 0, rad, true);
          cvs.ctx.clip();
          cvs.ctx.clearRect(0, 0, cvs.width, cvs.height);
          return cvs.ctx.restore();
        });
      }, 50);
    };
    frame = 0;
    if (hanabi.color === 'random') {
      hanabi.color = colorz.randHsl(100, 90, 60, 50, 90, 70).toString();
    }
    render = function() {
      var clear, e, index, s, _i, _len;
      if (!hibana.length) {
        return;
      }
      clear = 0;
      frame++;
      cvs.ctx.fillStyle = frame % 2 ? "rgba(256, 256, 256, 0.8)" : hanabi.color;
      for (index = _i = 0, _len = hibana.length; _i < _len; index = ++_i) {
        s = hibana[index];
        s.pos_x += s.vel_x;
        s.pos_y += s.vel_y;
        s.vel_x *= hanabi.circle;
        s.vel_y *= hanabi.circle;
        s.pos_y += hanabi.gravity;
        if (hanabi.size < 0.1 || !s.pos_x || !s.pos_y || s.pos_x > cvs.width || s.pos_y > cvs.height) {
          hibana[i] = void 0;
          if (len < ++clear) {
            try {
              window.parent.endAnimation(location.href);
            } catch (_error) {
              e = _error;
              ({});
            }
          }
          return;
        }
        cvs.ctx.beginPath();
        cvs.ctx.arc(s.pos_x, s.pos_y, hanabi.size, 0, rad, true);
        cvs.ctx.fill();
      }
      hanabi.size *= hanabi.circle;
      cvs.ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      cvs.ctx.fillRect(0, 0, cvs.width, cvs.height);
      return requestAnimationFrame(render);
    };
    cvs.elem = document.getElementById('hanabi');
    (function() {
      var b, d;
      b = document.body;
      d = document.documentElement;
      cvs.width = Math.max(b.clientWidth, b.scrollWidth, d.scrollWidth, d.clientWidth);
      return cvs.height = Math.max(b.clientHeight, b.scrollHeight, d.scrollHeight, d.clientHeight);
    })();
    cvs.elem.height = cvs.height;
    cvs.elem.width = cvs.width;
    cvs.ctx = cvs.elem.getContext('2d');
    cvs.left = cvs.elem.getBoundingClientRect ? cvs.elem.getBoundingClientRect().left : 0;
    return cvs.top = cvs.elem.getBoundingClientRect ? cvs.elem.getBoundingClientRect().top : 0;
  });

  (function(w, r) {
    return w['r' + r] = w['r' + r] || w['webkitR' + r] || w['mozR' + r] || w['msR' + r] || w['oR' + r] || function(c) {
      return w.setTimeout(c, 1000 / 60);
    };
  })(window, 'equestAnimationFrame');

}).call(this);
